@namespace Masa.Tsc.Web.Admin.Rcl.Components
@implements IDisposable
@inject I18n I18n

<div class="d-inline-flex align-center rounded-lg px-4 @Class"
     style="border:1px solid #E4E8F3; height: 40px; background-color:white;">
    <DateTimeRangePicker @bind-StartDateTime="_startDateTime"
                         StartTimeLimit="StartTimeLimit"
                         EndTimeLimit="EndTimeLimit"
                         @bind-EndDateTime="_endDateTime"
                         OnConfirm="OnAbsoluteDateTimeUpdated" OnTimeZoneInfoChange="OnTimeZoneInfoChange" />

    <MDivider Vertical Class="mx-2"></MDivider>

    <Dropdown @bind-Value="_selectedQuickRangeKey"
              Items="_quickRangeItems"
              ItemText="item => I18n.T(item.Key.ToString())"
              ItemValue="item => item.Key"
              ItemDisabled="item => item.Disabled"
              TItem="QuickRange"
              TValue="QuickRangeKey"
              OnItemClick="OnRelatedTimeSpanSelected"
              OffsetY
              NudgeBottom="@((StringNumber)8)" Class="text-capitalize">
        <ActivatorContent>
            <MButton Small @attributes="@context.Attrs" Text Class="text-capitalize">
                @I18n.T(_selectedQuickRangeKey.ToString())
                <MIcon Right>mdi-menu-down</MIcon>
            </MButton>
        </ActivatorContent>
    </Dropdown>

    <MDivider Vertical Class="mx-2" />

    <Dropdown Items="IntervalItem.Items"
              ItemValue="item => item"
              ItemText="item => I18n.T(item.Text)"
              @bind-Value="Interval"
              TItem="IntervalItem"
              TValue="IntervalItem"
              OnItemClick="OnIntervalSelected">
        <PrependContent>
            <MButton Icon Small OnClick="Refresh">
                <MIcon Small>mdi-refresh</MIcon>
            </MButton>
        </PrependContent>
        <ActivatorContent>
            @{
                var exists = Interval is not null;
                <MButton Text Small Icon="!exists"
                         @attributes="@context.Attrs">
                    <span class="mr-1">@I18n.T(Interval?.Text)</span>
                    <MIcon Small Right="@exists">mdi-menu-down</MIcon>
                </MButton>
            }
        </ActivatorContent>
    </Dropdown>
</div>

@code
{
    [Parameter]
    public QuickRangeKey? DefaultQuickRange { get; set; }

    [Parameter]
    public EventCallback<QuickRangeKey?> DefaultQuickRangeChanged { get; set; }

    [Parameter]
    public TimeSpan Offset { get; set; }

    [Parameter]
    public EventCallback<(DateTimeOffset, DateTimeOffset)> OnUpdate { get; set; }

    [Parameter]
    public EventCallback<(DateTimeOffset, DateTimeOffset)> OnAutoUpdate { get; set; }

    [Parameter]
    public EventCallback<TimeZoneInfo> OnTimeZoneUpdate { get; set; }

    [Parameter]
    public Func<DateOnly, DateOnly, bool> StartTimeLimit { get; set; }

    [Parameter]
    public Func<DateOnly, DateOnly, bool> EndTimeLimit { get; set; }

    [Parameter]
    public string Class { get; set; }

    [Parameter]
    public DateTimeOffset StartDateTime
    {
        get => _startDateTime;
        set => _startDateTime = value;
    }

    [Parameter]
    public DateTimeOffset EndDateTime
    {
        get => _endDateTime;
        set => _endDateTime = value;
    }

    [Parameter]
    public bool UseAbsoluteTime { get; set; } = false;

    [Parameter]
    public EventCallback<bool> UseAbsoluteTimeChanged { get; set; }

    [Parameter]
    public IntervalItem Interval { get; set; } = IntervalItem.Off;

    [Parameter]
    public EventCallback<IntervalItem?> IntervalChanged { get; set; }

    [Inject]
    public IUserContext UserContext { get; set; }

    [Inject]
    public JsInitVariables JsInitVariables { get; set; }

    private static readonly QuickRange s_internalDefaultQuickRange = new(QuickRangeKey.Last12Hours, TimeSpan.FromHours(-12));

    private Timer? _timer;
    private DateTimeOffset _startDateTime;
    private DateTimeOffset _endDateTime;
    private QuickRangeKey _selectedQuickRangeKey = QuickRangeKey.Off;
    private QuickRange _quickRange = s_internalDefaultQuickRange;

    private List<QuickRange> _quickRangeItems = new()
    {
        new QuickRange(QuickRangeKey.Last5Minutes, TimeSpan.FromMinutes(-5)),
        new QuickRange(QuickRangeKey.Last15Minutes, TimeSpan.FromMinutes(-15)),
        new QuickRange(QuickRangeKey.Last30Minutes, TimeSpan.FromMinutes(-30)),
        new QuickRange(QuickRangeKey.Last1Hour, TimeSpan.FromHours(-1)),
        new QuickRange(QuickRangeKey.Last3Hours, TimeSpan.FromHours(-3)),
        new QuickRange(QuickRangeKey.Last6Hours, TimeSpan.FromHours(-6)),
        s_internalDefaultQuickRange,
        new QuickRange(QuickRangeKey.Last24Hours, TimeSpan.FromHours(-24)),
        //new QuickRange(QuickRangeKey.Last2Days, TimeSpan.FromDays(-2)),
        //new QuickRange(QuickRangeKey.Last7Days, TimeSpan.FromDays(-7)),
        //new QuickRange(QuickRangeKey.Last30Days, TimeSpan.FromDays(-30)),
        //new QuickRange(QuickRangeKey.Last6Months, TimeSpan.FromDays(-180)),
        //new QuickRange(QuickRangeKey.Last1Year, TimeSpan.FromDays(-365)),
        //new QuickRange(QuickRangeKey.Yesterday),
        //new QuickRange(QuickRangeKey.DayBeforeYesterday),
        //new QuickRange(QuickRangeKey.DayLastWeek),
        //new QuickRange(QuickRangeKey.LastWeek),
        //new QuickRange(QuickRangeKey.LastMonth),
        //new QuickRange(QuickRangeKey.LastQuarter),
        //new QuickRange(QuickRangeKey.LastYear),
        //new QuickRange(QuickRangeKey.Today),
        //new QuickRange(QuickRangeKey.TodaySoFar),
        //new QuickRange(QuickRangeKey.ThisWeek),
        //new QuickRange(QuickRangeKey.ThisWeekSoFar),
        //new QuickRange(QuickRangeKey.ThisMonth),
        //new QuickRange(QuickRangeKey.ThisMonthSoFar),
        //new QuickRange(QuickRangeKey.ThisYear),
        //new QuickRange(QuickRangeKey.ThisYearSoFar),
        //new QuickRange(QuickRangeKey.Off, TimeSpan.Zero, true),
    };

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await base.OnAfterRenderAsync(firstRender);
            GetOffset();
            if (DefaultQuickRange is not null)
            {
                _quickRange = _quickRangeItems.FirstOrDefault(item => item.Key == DefaultQuickRange) ?? s_internalDefaultQuickRange;
            }
            else
            {
                DefaultQuickRange = _quickRange.Key;
            }

            _selectedQuickRangeKey = _quickRange.Key;

            if (UseAbsoluteTime is true && _startDateTime != DateTimeOffset.MinValue && _endDateTime != DateTimeOffset.MinValue)
            {
                await OnAbsoluteDateTimeUpdated();
            }
            else
            {  
                if (_quickRange.TryGetRange(Offset, out var value))
                {
                    _startDateTime = value.start;
                    _endDateTime = value.end;
                }
            
                await UpdateRangeDateTimeToLatest();
            }
            handleIntervalUpdate(Interval);
            StateHasChanged();
        }
    }

    private async Task OnTimeZoneInfoChange(TimeZoneInfo timeZoneInfo)
    {
        JsInitVariables.TimezoneOffset = timeZoneInfo.BaseUtcOffset;
        Offset = JsInitVariables.TimezoneOffset;
        if (DefaultQuickRange is not null)
        {
            _quickRange = _quickRangeItems.FirstOrDefault(item => item.Key == DefaultQuickRange) ?? s_internalDefaultQuickRange;
        }

        _selectedQuickRangeKey = _quickRange.Key;

        if (_quickRange.TryGetRange(Offset, out var value))
        {
            _startDateTime = value.start;
            _endDateTime = value.end;
        }

        if (OnTimeZoneUpdate.HasDelegate)
            await OnTimeZoneUpdate.InvokeAsync(timeZoneInfo);
        StateHasChanged();
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();

        GetOffset();

        if (DefaultQuickRange is not null)
        {
            _quickRange = _quickRangeItems.FirstOrDefault(item => item.Key == DefaultQuickRange) ?? s_internalDefaultQuickRange;
        }

        _selectedQuickRangeKey = _quickRange.Key;
    }

    private void GetOffset()
    {
        Offset = JsInitVariables.TimezoneOffset;
    }

    private async Task UpdateRangeDateTimeToLatest(bool autoUpdate = false)
    {
        if (_quickRange.TryGetRange(_endDateTime.Offset, out var value))
        {
            _startDateTime = value.start;
            _endDateTime = value.end;
        }

        if (OnUpdate.HasDelegate)
        {
            if (autoUpdate)
            {
                await OnAutoUpdate.InvokeAsync((_startDateTime, _endDateTime));
            }
            else
            {

                await OnUpdate.InvokeAsync((_startDateTime, _endDateTime));
            }
        }
    }

    private async Task OnAbsoluteDateTimeUpdated()
    {
        // _selectedQuickRangeKey = QuickRangeKey.Off;
        await updateUseAbsoluteTimeState(true);

        if (OnUpdate.HasDelegate)
        {
            await OnUpdate.InvokeAsync((_startDateTime, _endDateTime));
        }
    }

    private async Task OnRelatedTimeSpanSelected(QuickRange item)
    {
        _quickRange = item;
        await updateUseAbsoluteTimeState(false);
        await UpdateRangeDateTimeToLatest();
        if (DefaultQuickRangeChanged.HasDelegate)
            await DefaultQuickRangeChanged.InvokeAsync(item.Key);
    }

    private async Task OnIntervalSelected(IntervalItem item)
    {
        Interval = item;
        if (IntervalChanged.HasDelegate)
        {
            await IntervalChanged.InvokeAsync(Interval);
        }

        handleIntervalUpdate(Interval);
    }

    private void handleIntervalUpdate(IntervalItem item)
    {
        if (item.TimeSpan == TimeSpan.Zero)
        {
            _timer?.Stop();
            return;
        }

        if (_timer == null)
        {
            _timer = new()
                {
                    Interval = item.TimeSpan.TotalMilliseconds
                };

            _timer.Elapsed += TimerOnElapsed;
        }
        else
        {
            _timer.Stop();
            _timer.Interval = item.TimeSpan.TotalMilliseconds;
        }

        _timer.Start();
    }

    private void TimerOnElapsed(object? sender, ElapsedEventArgs e)
    {
        _ = UpdateRangeDateTimeToLatest(true);
        InvokeAsync(StateHasChanged);
    }

    private async Task updateUseAbsoluteTimeState(bool useAbsoluteTime)
    {
        UseAbsoluteTime = true;

        if (UseAbsoluteTimeChanged.HasDelegate)
        {
            await UseAbsoluteTimeChanged.InvokeAsync(useAbsoluteTime);
        }
    }

    private Task Refresh() => UpdateRangeDateTimeToLatest();

    public void Dispose()
    {
        _timer?.Dispose();
    }    
}